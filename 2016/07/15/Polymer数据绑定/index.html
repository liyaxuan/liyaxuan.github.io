<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Polymer数据绑定 · Hexo</title><meta name="description" content="Polymer数据绑定 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Polymer数据绑定</h1><div class="post-info">Jul 15, 2016</div><div class="post-content"><h2 id="术语说明"><a href="#术语说明" class="headerlink" title="术语说明"></a>术语说明</h2><p>在开始之前，为了避免混淆，先对下文中用到的术语——<code>property</code>和<code>attribute</code>，进行一些说明，如下所示。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- name is a attribute --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">name</span>=<span class="string">"alex"</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- innerTime is a property --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    Polymer(&#123;</div><div class="line">        is: <span class="string">'custom-inner'</span>,</div><div class="line">        properties: &#123;</div><div class="line">            innerTime: <span class="built_in">String</span>,</div><div class="line">            value: <span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="使用attribute声明数据绑定"><a href="#使用attribute声明数据绑定" class="headerlink" title="使用attribute声明数据绑定"></a>使用attribute声明数据绑定</h2><p>如下所示，外部组件的<code>outerTime</code>与内部组件的<code>innerTime</code>两个property建立了数据绑定。注意，这样写只是声明外部组件和内部组件的哪两个property建立了数据绑定，在最终运行的入口HTML中（比如<code>index.html</code>）用浏览器开发者工具查看，只会看到裸的<code>&lt;custom-inner&gt;&lt;/custom-inner&gt;</code>，没有任何attribute。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dom-moulde</span> <span class="attr">id</span>=<span class="string">"custom-outer"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">custom-inner</span> <span class="attr">inner-time</span>=<span class="string">"&#123;&#123;outerTime&#125;&#125;"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dom-moulde</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>因为我们的组件代码都是写在<code>&lt;dom-module&gt;&lt;/dom-module&gt;</code>里面，通过<code>&lt;link rel=&quot;import&quot;&gt;</code>的方式导入，导入以后Polymer会对组件代码进行parse，检测到<code>inner-time=&quot; {{outerTime}} &quot;</code>时就会意识到这是一个数据绑定的声明，于是建立数据绑定，在最终生成的DOM中并不会保留<code>inner-time</code>这个attribute。<br>所以如果按照下面这样的写法，是不会有任何作用的，结果只是在<code>custom-inner</code>这个元素上添加一个<code>inner-time</code>的attribute。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in outer component</span></div><div class="line"><span class="keyword">this</span>.root.querySelector(<span class="string">'custom-inner'</span>).setAttribute(<span class="string">'inner-time'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().toString());</div></pre></td></tr></table></figure></p>
<h2 id="property-property的数据绑定"><a href="#property-property的数据绑定" class="headerlink" title="property - property的数据绑定"></a>property - property的数据绑定</h2><p>property - property的绑定默认是单向的，经过配置也可以变成双向的，取决于三个因素。</p>
<ul>
<li><code>{{}}</code>还是<code>[[]]</code></li>
<li>property的<code>notify</code>属性，true还是false</li>
<li>property的<code>readOnly</code>属性，true还是false</li>
</ul>
<p><code>{{}}</code>表示建立的是双向数据绑定，<code>[[]]</code>建立的则是单向数据绑定。如下所示，外部组件的<code>mainProp</code>和内部组件的<code>innerProp</code>建立了数据绑定，两种写法都可以实现，mainProp -&gt; innerProp的更新。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 双向数据绑定 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">custom-inner</span> <span class="attr">inner-prop</span>=<span class="string">"&#123;&#123;mainProp&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-inner</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 单向数据绑定 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">custom-inner</span> <span class="attr">inner-prop</span>=<span class="string">"[[mainProp]]"</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-inner</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>实现双向数据绑定，除了<code>{{}}</code>，还需要在内部组件中为<code>innerProp</code>设置<code>notify: true</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">properties: &#123;</div><div class="line">    innerProp: &#123;</div><div class="line">        type: <span class="built_in">String</span>,</div><div class="line">        notify: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，如果使用<code>[[]]</code>声明单向数据绑定，设置<code>notify: true</code>也就不会起作用了。</p>
<h3 id="notify的传递"><a href="#notify的传递" class="headerlink" title="notify的传递"></a>notify的传递</h3><p>还是这个例子，innerTime的<code>notify: true</code>只能将innerTime的更新同步到outerTime，如果outerTime不设置<code>notify: true</code>，mainTime就不会更新，也就是说innerTime从内向外的数据流动在<code>custom-outer</code>这一层“断”了。如果要从嵌套的内部组件同步property到外部组件，除了最后的外部组件（或者数据流动的终点组件），都要逐层设置<code>notify: true</code>。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">custom-main</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">custom-outer</span> <span class="attr">outer-Time</span>=<span class="string">"&#123;&#123;mainTime&#125;&#125;"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">custom-inner</span> <span class="attr">inner-Time</span>=<span class="string">"&#123;&#123;outerTime&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-inner</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">custom-outer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">custom-main</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然而不这么做，外层组件也有一些方法与内层组件的property同步。</p>
<h3 id="property-changed事件"><a href="#property-changed事件" class="headerlink" title="property-changed事件"></a>property-changed事件</h3><p>为一个property设置<code>notify: true</code>会使Polymer在该property改变时触发<code>property-changed</code>事件，比如<code>innerTime</code>的值改变时就会触发<code>inner-time-changed</code>事件，即property在这里要从camel-case变成dash-case。<br>在这里，我想讨论的是这个事件的冒泡问题，首先引用一段官方文档。</p>
<blockquote>
<p>When the property changes, the element fires a non-bubbling DOM event  </p>
</blockquote>
<p>按照官方文档的说法，这个事件是不会冒泡的。我个人对此的理解是，如果有下面的结构，并且innerTime设置<code>notify: true</code>的话，<code>custom-outer</code>可以监听到<code>inner-time-changed</code>事件，而<code>custom-main</code>不可以。然而我做了个测试，发现并非如此。<br><strong><em>（注意，这样的写法并不正确，仅作示意，表示嵌套关系）</em></strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">custom-main</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">custom-outer</span> <span class="attr">outer-Time</span>=<span class="string">"&#123;&#123;mainTime&#125;&#125;"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">custom-inner</span> <span class="attr">inner-Time</span>=<span class="string">"&#123;&#123;outerTime&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-inner</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">custom-outer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">custom-main</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>首先在<code>custom-inner</code>中设置定时器去修改<code>innerTime</code>的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ready: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</div><div class="line">    setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        _this.innerTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着在<code>custom-main</code>和<code>custom-outer</code>两个组件的<code>created</code>回调函数中建立监听innerTime值变化的<code>inner-time-changed</code>事件监听。<code>e.target</code>是事件当前传播到的DOM对象，<code>e.detail.value</code>就是<code>innerTime</code>的当前值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">changed: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(e.target);</div><div class="line">    <span class="built_in">console</span>.log(e.detail.value);</div><div class="line">&#125;,</div><div class="line">created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.listen(<span class="keyword">this</span>, <span class="string">'inner-time-changed'</span>, <span class="string">'changed'</span>);</div><div class="line">    <span class="comment">// this.listen(this.root, 'inner-time-changed', 'changed');</span></div><div class="line">    <span class="comment">// is ok too</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果是<code>custom-main</code>和<code>custom-outer</code>都触发了changed()，输出如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;custom-outer&gt;&lt;/custom-outer&gt;</div><div class="line">Thu Jul 14 2016 20:42:11 GMT+0800 (中国标准时间)</div><div class="line">&lt;custom-main&gt;&lt;/custom-main&gt;</div><div class="line">Thu Jul 14 2016 20:42:11 GMT+0800 (中国标准时间)</div></pre></td></tr></table></figure></p>
<p>至于<code>readOnly</code>属性，很好理解。如果property是只读的，那么除了通过<code>value</code>赋初值以外，无法被修改。不过Polymer还是提供了<code>this._setProperty(value)</code>这个方法，可以手动调用对<code>readOnly</code>为<code>true</code>的property赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Polymer(&#123;</div><div class="line">    properties: &#123;</div><div class="line">        response: &#123;</div><div class="line">            type: <span class="built_in">Object</span>,</div><div class="line">            readOnly: <span class="literal">true</span>,</div><div class="line">            notify: <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    responseHandler: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>._setResponse(response);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="notify和observer的区别"><a href="#notify和observer的区别" class="headerlink" title="notify和observer的区别"></a>notify和observer的区别</h3><p>从字面意思来看，<code>notify</code>是通知，<code>observer</code>是观察，对应到它们的功能，理解起来也非常自然。</p>
<ul>
<li>设置<code>notify: true</code>的property会在值更新时，触发更新事件。这个事件从当前组件开始（会在当前组件触发一次），向外部传递，是用来从内向外发射消息的，用于建立从内部到外部的数据流动。</li>
<li><code>observer</code>指定一个当前组件的方法，在每次检测到property的值变化时调用，主要作用于当前组件，监视当前组件property的变化。  </li>
</ul>
<p>当然，两者从本质上讲都是Polymer内建的自定义事件系统。在内部组件<code>observer</code>指定的方法中使用<code>this.fire()</code>发射事件，在外部组件的<code>created</code>或者<code>ready</code>回调函数中建立事件监听，也可以实现<code>notify</code>的效果；为property设置了<code>notify: true</code>的组件也可以建立<code>property-changed</code>事件监听，来实现<code>observer</code>的效果。具体采用什么方式，可以具体情况具体分析。</p>
<h3 id="value与notify和observer"><a href="#value与notify和observer" class="headerlink" title="value与notify和observer"></a>value与notify和observer</h3><p>每个组件在初始化的过程中（<code>created</code>和<code>ready</code>状态之间），组件的每个property的oldValue是<code>undefined</code>。如果在传给Polymer()工厂方法的配置对象中为property设置了<code>value</code>，那么会引发一次<code>notify</code>的事件触发和<code>observer</code>的调用，<code>observer</code></p>
<h2 id="property-attribute"><a href="#property-attribute" class="headerlink" title="property - attribute"></a>property - attribute</h2><p>property - attribute的绑定是单向的，可以从property更新到attribute，修改attribute无法引起property更新。<br>如下所示，有一个time <code>attribute</code>和time <code>property</code>。如果设置一个定时器更新time <code>property</code>的值，time <code>attribute</code>也会更新。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color: green;"</span> <span class="attr">time</span>$=<span class="string">"&#123;&#123;time&#125;&#125;"</span>&gt;</span>inner: &#123;&#123;time&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>反之，如果修改attribute，property则不会更新，也就是说看不到<code>&lt;h1&gt;&lt;/h1&gt;</code>中的文本的变化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.root.querySelector(<span class="string">'h1'</span>).setAttribute(<span class="string">'time'</span>, <span class="string">'xxxx'</span>)</div></pre></td></tr></table></figure></p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>AngularJS、Vue.js支持在<code>{{}}</code>中插入表达式。Polymer对此不支持，如下所示。如果这么写，最后渲染出的会是<code>&lt;h1&gt;inner: &lt;/h1&gt;</code>。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">"color: green;"</span> <span class="attr">time</span>$=<span class="string">"&#123;&#123;time&#125;&#125;"</span>&gt;</span>inner: &#123;&#123;time + ‘233333’&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>唯一支持的是求反运算，例如<code>{{!someProperty}}</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">hidden</span>=<span class="string">"&#123;&#123;!enabled&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>下面这种写法叫做<code>compound binding</code>，Polymer是支持的，因为<code>{{}}</code>中并没有表达式。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>$=<span class="string">"https://www.example.com/profiles/&#123;&#123;userId&#125;&#125;.jpg"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Name: &#123;&#123;lastname&#125;&#125;, &#123;&#123;firstname&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>想要实现绑定一个表达式运算结果的功能，可以使用<code>computed binding</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">    My name is <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;computeFullName(first, last)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">Polymer(&#123;</div><div class="line">    is: <span class="string">'x-custom'</span>,</div><div class="line">    properties: &#123;</div><div class="line">        first: <span class="built_in">String</span>,</div><div class="line">        last: <span class="built_in">String</span></div><div class="line">    &#125;,</div><div class="line">    computeFullName: <span class="function"><span class="keyword">function</span>(<span class="params">first, last</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> first + <span class="string">' '</span> + last;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="输入控件的数据绑定"><a href="#输入控件的数据绑定" class="headerlink" title="输入控件的数据绑定"></a>输入控件的数据绑定</h2><p>输入控件的一些原生属性不能使用<code>attribute$=&quot;{{property}}&quot;</code>的写法，下面这样的写法会导致异常。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- would throw an error --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>$=<span class="string">"&#123;&#123;hostVaule&#125;&#125;"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- no reaction --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>$=<span class="string">"&#123;&#123;hostChecked&#125;&#125;"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>正确的写法如下，<code>hostValue</code>和<code>hostChecked</code>两个property分别在<code>input</code>事件和<code>change</code>事件发生后会与<code>&lt;input&gt;.value</code>和<code>&lt;input&gt;.checked</code>同步。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Listens for `input` event and sets hostValue to &lt;input&gt;.value --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"&#123;&#123;hostValue::input&#125;&#125;"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- Listens for `change` event and sets hostChecked to &lt;input&gt;.checked --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>=<span class="string">"&#123;&#123;hostChecked::change&#125;&#125;"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>官方文档给出的例子很有限，也没有说明到底支持哪些元素、这些元素的哪些事件、这些事件引起的哪些属性的变化可以与property进行数据绑定，使用前还须进行测试。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/07/15/Polymer组件的生命周期/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com">John Doe</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>